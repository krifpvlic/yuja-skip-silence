<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synced Video Player</title>
    <style>
        video { width: 48%; }
        .container { display: flex; justify-content: space-between; }
        .transcript-wrapper {
        display: flex;
        align-items: flex-start; /* Align items at the top */
        position: relative;
        margin-right: 15px; /* Add space for timeline */
        border: 1px solid #ccc;

        margin-top: 20px;
    }
        .transcript-container {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            position: relative;
            
            flex-grow: 1; /* Allow transcript to take up remaining space */

        }
        .transcript-line {
        padding: 4px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
        .transcript-line.active {
            background-color: #e0e0e0;
        }
        .bookmark-circle {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
    }
    .bookmark-circle:hover {
        border-color: #666;
    }
    /* Add styles for the bookmark timeline */
    .bookmark-timeline {
        width: 5px;
        height: 220px; /* Match container height */
        background-color: #f0f0f0;
        z-index: 10;
        position: relative;
    }
    .timeline-marker {
        position: absolute;
        left: 0;
        width: 5px;
        height: 5px;
        border-radius: 0;
        cursor: pointer;
    }
    .bookmark-notes {
        position: absolute;
        right: 30px;
        background: white;
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
    }
    .bookmark-notes textarea {
        width: 200px;
        height: 100px;
        margin-bottom: 10px;
    }
    .color-picker {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
    }
    .color-option {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
    }
    .color-option:hover {
        border-color: #666;
    }
    .bookmark-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
    }
    
    .bookmark-buttons button {
        flex: 1;
        margin: 0 5px;
        padding: 5px;
        cursor: pointer;
    }
    
    .bookmark-buttons button:first-child {
        margin-left: 0;
    }
    
    .bookmark-buttons button:last-child {
        margin-right: 0;
    }
    </style>
</head>
<body>
    <h2>Synced Video Player</h2>
    
    <!-- Replace individual file inputs with a folder picker -->
    <button id="selectFolderBtn">Select Folder</button>
    <div id="selectedFiles">
        <p>PCI0 Video: <span id="pci0File">None</span></p>
        <p>PCI1 Video: <span id="pci1File">None</span></p>
        <p>Subtitle: <span id="srtFile">None</span></p>
    </div>
    
    <div class="subtitle-controls">
        <label for="subtitleDelay">Subtitle Delay (seconds):</label>
        <input type="number" id="subtitleDelay" step="0.1" value="0">
        
        <label for="subtitleStretch">Subtitle Stretch Factor:</label>
        <input type="number" id="subtitleStretch" step="0.0001" value="1.0000" min="0.5" max="2.0">
        
        <button id="applySubtitleSettings">Apply</button>
        <button id="saveSettings">Save Settings</button>
        <button id="toggleSubtitles">Toggle Subtitles</button>
    </div>
    
    <div class="container">
        <video id="videoWithAudio" controls>
            <track id="subtitleTrack" kind="subtitles" srclang="en" label="English" default>
        </video>
        <video id="videoWithoutAudio" muted></video>
    </div>
    <div class="transcript-wrapper">
        <div id="transcript" class="transcript-container"></div>
        <div class="bookmark-timeline" id="bookmarkTimeline"></div>
    </div>
    </div>
    
    <script>
        const videoWithAudio = document.getElementById("videoWithAudio");
        const videoWithoutAudio = document.getElementById("videoWithoutAudio");
        const subtitleTrack = document.getElementById("subtitleTrack");
        const transcriptContainer = document.getElementById("transcript");
        const bookmarkTimeline = document.getElementById("bookmarkTimeline");
        const toggleSubtitlesBtn = document.getElementById("toggleSubtitles");
        const seekAmount = 5; // Adjust arrow key seek time in seconds
        
        // Subtitle timing control variables
        const subtitleDelayInput = document.getElementById("subtitleDelay");
        const subtitleStretchInput = document.getElementById("subtitleStretch");
        const applySubtitleSettingsBtn = document.getElementById("applySubtitleSettings");
        const saveSettingsBtn = document.getElementById("saveSettings");
        let subtitleDelay = 0;
        let subtitleStretch = 1.0;
        let originalSrtContent = "";
        let currentSubtitleIndex = -1;
        let subtitles = [];
        
        // File handling variables
        let directoryHandle = null;
        let pci0File = null;
        let pci1File = null;
        let srtFile = null;
        
        // Add variables for tracking video position
        let lastSavedPosition = 0;
        let positionSaveThreshold = 5; // Save when position changes by 5 seconds
        let positionSaveTimer = null;
        
        // Add folder selection functionality
        document.getElementById("selectFolderBtn").addEventListener("click", async () => {
            try {
                directoryHandle = await window.showDirectoryPicker();
                await processDirectory(directoryHandle);
            } catch (error) {
                console.error("Error selecting folder:", error);
                alert("Error selecting folder: " + error.message);
            }
        });
        
        // Process the selected directory to find the required files
        async function processDirectory(dirHandle) {
            pci0File = null;
            pci1File = null;
            srtFile = null;
            
            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file') {
                    const name = entry.name.toLowerCase();
                    
                    if (name.includes('pci0') && (name.endsWith('.mp4') || name.endsWith('.webm') || name.endsWith('.mov'))) {
                        pci0File = entry;
                        document.getElementById("pci0File").textContent = entry.name;
                    } else if (name.includes('pci1') && (name.endsWith('.mp4') || name.endsWith('.webm') || name.endsWith('.mov'))) {
                        pci1File = entry;
                        document.getElementById("pci1File").textContent = entry.name;
                    } else if (name.endsWith('.srt')) {
                        srtFile = entry;
                        document.getElementById("srtFile").textContent = entry.name;
                    } else if (name === 'settings.json') {
                        // Load settings if found
                        await loadSettings(entry);
                    }
                }
            }
            await loadBookmarks();

            
            // Load the files if found
            if (pci0File && pci1File && srtFile) {
                await loadFiles();
            } else {
                alert("Could not find all required files. Please ensure the folder contains files with PCI0, PCI1 in their names and a .srt file.");
            }
        }
        
        // Load the files into the player
        async function loadFiles() {
            try {
                // Load PCI0 video (with audio)
                const pci0FileObj = await pci0File.getFile();
                videoWithAudio.src = URL.createObjectURL(pci0FileObj);
                
                // Load PCI1 video (without audio)
                const pci1FileObj = await pci1File.getFile();
                videoWithoutAudio.src = URL.createObjectURL(pci1FileObj);
                
                // Load subtitle file
                const srtFileObj = await srtFile.getFile();
                const srtContent = await srtFileObj.text();
                originalSrtContent = srtContent;
                updateTranscript(srtContent);
                applySubtitleSettings();
                
                // Set up video position tracking
                videoWithAudio.addEventListener("loadedmetadata", () => {
                    // Set the video position from settings if available
                    if (lastSavedPosition > 0) {
                        videoWithAudio.currentTime = lastSavedPosition;
                    }
                });
                
                // Set up periodic position saving
                let lastSaveTime = Date.now();
                videoWithAudio.addEventListener("timeupdate", () => {
                    const currentTime = videoWithAudio.currentTime;
                    const now = Date.now();
                    if(now-lastSaveTime >= 5500){
                        lastSaveTime = now;
                    }
                    
                    // Save if position changed significantly or enough time has passed (10 seconds)
                    if (Math.abs(currentTime - lastSavedPosition) >= positionSaveThreshold && 
                        now - lastSaveTime >= 5000) {
                        lastSavedPosition = currentTime;
                        lastSaveTime = now;
                        saveSettings();
                    }
                });
                // Check if enough time has passed since last save
                // const currentTime = videoWithAudio.currentTime;
                // if (Math.abs(currentTime - lastSavedPosition) >= positionSaveThreshold) {
                //     lastSavedPosition = currentTime;
                //     saveSettings();
                // }
                //
                // Still keep the debounce timer for when video is paused
                // clearTimeout(positionSaveTimer);
                // positionSaveTimer = setTimeout(saveVideoPosition, 1000);
            } catch (error) {
                console.error("Error loading files:", error);
                alert("Error loading files: " + error.message);
            }
        }
        
        // Save settings to settings.json
        async function saveSettings() {
            if (!directoryHandle) {
                alert("Please select a folder first");
                return;
            }
            
            const settings = {
                subtitleDelay: parseFloat(subtitleDelayInput.value) || 0,
                subtitleStretch: parseFloat(subtitleStretchInput.value) || 1.0,
                videoPosition: videoWithAudio.currentTime || 0
            };
            
            try {
                // Create or overwrite settings.json
                const settingsFileHandle = await directoryHandle.getFileHandle('settings.json', { create: true });
                const writable = await settingsFileHandle.createWritable();
                await writable.write(JSON.stringify(settings, null, 2));
                await writable.close();
                console.log("Settings saved successfully");
            } catch (error) {
                console.error("Error saving settings:", error);
            }
        }
        
        // Load settings from settings.json
        async function loadSettings(fileHandle) {
            try {
                const file = await fileHandle.getFile();
                const content = await file.text();
                const settings = JSON.parse(content);
                
                if (settings.subtitleDelay !== undefined) {
                    subtitleDelayInput.value = settings.subtitleDelay;
                    subtitleDelay = settings.subtitleDelay;
                }
                
                if (settings.subtitleStretch !== undefined) {
                    subtitleStretchInput.value = settings.subtitleStretch;
                    subtitleStretch = settings.subtitleStretch;
                }
                
                if (settings.videoPosition !== undefined) {
                    lastSavedPosition = settings.videoPosition;
                }
                
                console.log("Settings loaded:", settings);
            } catch (error) {
                console.error("Error loading settings:", error);
            }
        }
        
        // Add function to save video position
        function saveVideoPosition() {
            if (!directoryHandle) return;
            
            const currentPosition = videoWithAudio.currentTime;
            // Only save if position changed by more than threshold
            if (Math.abs(currentPosition - lastSavedPosition) >= positionSaveThreshold) {
                lastSavedPosition = currentPosition;
                saveSettings();
            }
        }
        
        // Add event listener for save settings button
        saveSettingsBtn.addEventListener("click", saveSettings);

        toggleSubtitlesBtn.addEventListener("click", () => {
            if (subtitleTrack.track.mode === "showing") {
                subtitleTrack.track.mode = "hidden";
                toggleSubtitlesBtn.textContent = "Show Subtitles";
            } else {
                subtitleTrack.track.mode = "showing";
                toggleSubtitlesBtn.textContent = "Hide Subtitles";
            }
        });

        // Add bookmark-related variables
        let bookmarks = {};
        const defaultBookmarkColor = '#87CEEB'; // light blue
        const bookmarkColors = ['#87CEEB', '#90EE90', '#FFB6C1', '#DDA0DD', '#F0E68C']; // light blue, light green, light pink, plum, khaki
        
        // Load bookmarks from bookmarks.json
        async function loadBookmarks() {
            if (!directoryHandle) return;
            
            try {
                const bookmarksHandle = await directoryHandle.getFileHandle('bookmarks.json', { create: true });
                const file = await bookmarksHandle.getFile();
                const content = await file.text();
                bookmarks = JSON.parse(content || '{}');
                updateBookmarkTimeline();
            } catch (error) {
                console.error("Error loading bookmarks:", error);
                bookmarks = {};
            }
        }
        
        // Save bookmarks to bookmarks.json
        async function saveBookmarks() {
            if (!directoryHandle) return;
            
            try {
                const bookmarksHandle = await directoryHandle.getFileHandle('bookmarks.json', { create: true });
                const writable = await bookmarksHandle.createWritable();
                await writable.write(JSON.stringify(bookmarks, null, 2));
                await writable.close();
            } catch (error) {
                console.error("Error saving bookmarks:", error);
            }
        }
        
        // Modify the updateTranscript function
        function updateTranscript(srtContent) {
            subtitles = parseSRT(srtContent);
            transcriptContainer.innerHTML = `
                ${subtitles
                    .map((sub, index) => `
                        <div class="transcript-line" data-index="${index}">
                            <span>${sub.text}</span>
                            <div class="bookmark-circle" data-index="${index}" 
                                 style="background-color: ${bookmarks[index]?.color || 'transparent'}">
                            </div>
                        </div>
                    `).join("")}
            `;
            
            // Add click handlers for transcript lines and bookmarks
            document.querySelectorAll('.transcript-line').forEach(line => {
                const index = parseInt(line.dataset.index);
                
                // Text click handler
                line.querySelector('span').addEventListener('click', () => {
                    const adjustedTime = subtitles[index].startTime * subtitleStretch + subtitleDelay;
                    videoWithAudio.currentTime = adjustedTime;
                });
                
                // Bookmark click handler
                const bookmarkCircle = line.querySelector('.bookmark-circle');
                bookmarkCircle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleBookmarkClick(index, bookmarkCircle);
                });
            });
            
            // Update the bookmark timeline
            updateBookmarkTimeline();
            
            // Add keyboard navigation for transcript
            transcriptContainer.tabIndex = 0; // Make the container focusable
            transcriptContainer.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    event.preventDefault(); // Prevent default scrolling
                    
                    // Find the current active line or use the first one
                    const activeLine = document.querySelector('.transcript-line.active') || 
                                       document.querySelector('.transcript-line');
                    if (!activeLine) return;
                    
                    const currentIndex = parseInt(activeLine.dataset.index);
                    let newIndex;
                    
                    if (event.key === 'ArrowDown' && currentIndex < subtitles.length - 1) {
                        newIndex = currentIndex + 1;
                    } else if (event.key === 'ArrowUp' && currentIndex > 0) {
                        newIndex = currentIndex - 1;
                    } else {
                        return; // No valid navigation
                    }
                    
                    // Simulate clicking the new line
                    const newLine = document.querySelector(`.transcript-line[data-index="${newIndex}"]`);
                    if (newLine) {
                        newLine.click();
                        newLine.focus(); // Optional: focus the new line for accessibility
                    }
                }
            });
        }
        // Add a new function to update the bookmark timeline
function updateBookmarkTimeline() {
    const timeline = document.getElementById('bookmarkTimeline');
    timeline.innerHTML = '';
    
    if (subtitles.length === 0) return;
    
    // Create markers for each bookmark
    Object.keys(bookmarks).forEach(index => {
        const i = parseInt(index);
        if (i >= 0 && i < subtitles.length) {
            const position = (i / subtitles.length) * 100;
            const marker = document.createElement('div');
            console.log("creating marker at position", position);
            marker.className = 'timeline-marker';
            const markerHeight = 5; // Set a consistent height for markers
            marker.style.height = `${markerHeight}px`;
            const adjustedPosition = (position * (100 - markerHeight/timeline.clientHeight*100)) / 100;
            marker.style.top = `${adjustedPosition}%`;
            marker.style.backgroundColor = bookmarks[i].color;
            marker.dataset.index = i;

            
            // Add click handler to jump to the bookmark
            marker.addEventListener('click', () => {
                const adjustedTime = subtitles[i].startTime * subtitleStretch + subtitleDelay;
                videoWithAudio.currentTime = adjustedTime;
                
                // Scroll to the corresponding transcript line
                const line = document.querySelector(`.transcript-line[data-index="${i}"]`);
                if (line) {
                    scrollParentToChild(transcriptContainer, line);
                }
            });
            timeline.appendChild(marker);
        }
    });
}


function handleBookmarkClick(index, circle) {
    if (bookmarks[index]) {
        showBookmarkNotes(index, circle);
    } else {
        // Create new bookmark
        bookmarks[index] = {
            color: defaultBookmarkColor,
            notes: ''
        };
        circle.style.backgroundColor = defaultBookmarkColor;
        showBookmarkNotes(index, circle);
        saveBookmarks();
        updateBookmarkTimeline();
    }
}

function showBookmarkNotes(index, circle) {
    const existingNotes = document.querySelector('.bookmark-notes');
    if (existingNotes) existingNotes.remove();
    
    const notesDiv = document.createElement('div');
    notesDiv.className = 'bookmark-notes';
    notesDiv.innerHTML = `
        <div class="color-picker">
            ${bookmarkColors.map(color => 
                `<div class="color-option" style="background-color: ${color}"></div>`
            ).join('')}
        </div>
        <textarea placeholder="Add notes...">${bookmarks[index]?.notes || ''}</textarea>
        <div class="bookmark-buttons">
            <button class="save-btn">Save</button>
            <button class="cancel-btn">Cancel</button>
            <button class="delete-btn">Delete</button>
        </div>
    `;
    
    // Position the notes div
    const rect = circle.getBoundingClientRect();
    notesDiv.style.top = `${rect.top}px`;
    document.body.appendChild(notesDiv);
    
    // Color picker handlers
    notesDiv.querySelectorAll('.color-option').forEach(colorDiv => {
        colorDiv.addEventListener('click', () => {
            const color = colorDiv.style.backgroundColor;
            bookmarks[index].color = color;
            circle.style.backgroundColor = color;
            saveBookmarks();
        });
    });
    
    // Button handlers
    const saveBtn = notesDiv.querySelector('.save-btn');
    const cancelBtn = notesDiv.querySelector('.cancel-btn');
    const deleteBtn = notesDiv.querySelector('.delete-btn');
    
    saveBtn.addEventListener('click', () => {
        bookmarks[index].notes = notesDiv.querySelector('textarea').value;
        saveBookmarks();
        updateBookmarkTimeline();
        notesDiv.remove();
    });
    
    cancelBtn.addEventListener('click', () => {
        notesDiv.remove();
    });
    
    deleteBtn.addEventListener('click', () => {
        delete bookmarks[index];
        circle.style.backgroundColor = 'transparent';
        saveBookmarks();
        updateBookmarkTimeline();
        notesDiv.remove();
    });
    
    // Click outside to close and save
    document.addEventListener('click', function closeNotes(e) {
        if (!notesDiv.contains(e.target) && e.target !== circle) {
            // Save notes before closing
            bookmarks[index].notes = notesDiv.querySelector('textarea').value;
            saveBookmarks();
            updateBookmarkTimeline();
            
            notesDiv.remove();
            document.removeEventListener('click', closeNotes);
        }
    });
}

        function parseSRT(srtContent) {
            const parsed = [];
            const blocks = srtContent.trim().split('\n\n');
            
            blocks.forEach(block => {
                const lines = block.split('\n');
                if (lines.length >= 3) {
                    const times = lines[1].match(/(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/);
                    if (times) {
                        const startTime = parseInt(times[1]) * 3600 + parseInt(times[2]) * 60 + parseInt(times[3]) + parseInt(times[4]) / 1000;
                        const text = lines.slice(2).join('\n');
                        parsed.push({ startTime, text });
                    }
                }
            });
            return parsed;
        }

        function scrollParentToChild(parent, child) {
            // Get the parent's dimensions and position
            const parentRect = parent.getBoundingClientRect();
            const parentHeight = parent.clientHeight;
            
            // Get the child's dimensions and position
            const childRect = child.getBoundingClientRect();
            const childHeight = child.offsetHeight;
            
            // Calculate the position that would center the child in the parent
            const childRelativeTop = childRect.top - parentRect.top;
            const targetScrollTop = parent.scrollTop + childRelativeTop - (parentHeight/2) + (childHeight/2);
            
            // Smoothly scroll to center the child
            parent.scrollTo({
                top: targetScrollTop,
                behavior: 'smooth'
            });
        }

        function updateActiveTranscriptLine() {
            const currentTime = videoWithAudio.currentTime;
            const newIndex = subtitles.findIndex((sub, index) => {
                const nextSub = subtitles[index + 1];
                // Adjust the subtitle timing with stretch and delay
                const adjustedStartTime = sub.startTime * subtitleStretch + subtitleDelay;
                const adjustedNextTime = nextSub ? nextSub.startTime * subtitleStretch + subtitleDelay : Infinity;
                
                return currentTime >= adjustedStartTime && currentTime < adjustedNextTime;
            });

            if (newIndex !== currentSubtitleIndex && newIndex !== -1) {
                document.querySelectorAll('.transcript-line').forEach(el => el.classList.remove('active'));
                const activeLine = document.querySelector(`.transcript-line[data-index="${newIndex}"]`);
                if (activeLine) {
                    activeLine.classList.add('active');
                    scrollParentToChild(transcriptContainer, activeLine);
                }
                currentSubtitleIndex = newIndex;
            }
        }
        
        // Modify the existing subtitle input handler
        // document.getElementById("subtitleInput").addEventListener("change", function(event) {
        //     const file = event.target.files[0];
        //     const reader = new FileReader();
        //     reader.onload = function(e) {
        //         originalSrtContent = e.target.result;
        //         updateTranscript(originalSrtContent);
        //         applySubtitleSettings();
        //     };
        //     reader.readAsText(file);
        // });

        // Add timeupdate listener for transcript tracking
        videoWithAudio.addEventListener("timeupdate", updateActiveTranscriptLine);

        applySubtitleSettingsBtn.addEventListener("click", applySubtitleSettings);

        function applySubtitleSettings() {
            if (!originalSrtContent) return;
            
            subtitleDelay = parseFloat(subtitleDelayInput.value) || 0;
            subtitleStretch = parseFloat(subtitleStretchInput.value) || 1.0;
            
            const vttData = convertSRTtoVTT(originalSrtContent, subtitleDelay, subtitleStretch);
            const blob = new Blob([vttData], { type: "text/vtt" });
            subtitleTrack.src = URL.createObjectURL(blob);
            subtitleTrack.track.mode = "showing";
        }

        function convertSRTtoVTT(data, delay = 0, stretch = 1.0) {
            // console.log("Original SRT data:", data);
            let vtt = "WEBVTT\n\n" + data
                .replace(/(\d+)\n(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/g, 
                         (match, id, h1, m1, s1, ms1, h2, m2, s2, ms2) => {
                            //  console.log("Match found:", match);
                             
                             // Convert timestamps to seconds
                             let startTime = parseInt(h1) * 3600 + parseInt(m1) * 60 + parseInt(s1) + parseInt(ms1) / 1000;
                             let endTime = parseInt(h2) * 3600 + parseInt(m2) * 60 + parseInt(s2) + parseInt(ms2) / 1000;
                             
                             // Apply stretch and delay
                             startTime = startTime * stretch + delay;
                             endTime = endTime * stretch + delay;
                             
                             // Convert back to timestamp format
                             let newH1 = Math.floor(
                                 startTime / 3600).toString().padStart(2, '0');
                             let newM1 = Math.floor((startTime % 3600) / 60).toString().padStart(2, '0');
                             let newS1 = Math.floor(startTime % 60).toString().padStart(2, '0');
                             let newMs1 = Math.floor((startTime % 1) * 1000).toString().padStart(3, '0');
                             
                             let newH2 = Math.floor(endTime / 3600).toString().padStart(2, '0');
                             let newM2 = Math.floor((endTime % 3600) / 60).toString().padStart(2, '0');
                             let newS2 = Math.floor(endTime % 60).toString().padStart(2, '0');
                             let newMs2 = Math.floor((endTime % 1) * 1000).toString().padStart(3, '0');
                             
                            //  console.log("Adjusted timestamp:", `${newH1}:${newM1}:${newS1}.${newMs1} --> ${newH2}:${newM2}:${newS2}.${newMs2}`);
                             return `${id}\n${newH1}:${newM1}:${newS1}.${newMs1} --> ${newH2}:${newM2}:${newS2}.${newMs2}`;
                         });
            // console.log("Converted VTT data:", vtt);
            return vtt;
        }


       
        // Add save settings button event listener
        document.getElementById("saveSettings").addEventListener("click", saveSettings);


        function syncVideos() {
            videoWithoutAudio.currentTime = videoWithAudio.currentTime;
            // Removed the line that forces subtitles to show
        }

        videoWithAudio.addEventListener("play", () => {
            videoWithoutAudio.play();
            syncVideos();
        });
        videoWithAudio.addEventListener("pause", () => videoWithoutAudio.pause());
        videoWithAudio.addEventListener("ratechange", () => videoWithoutAudio.playbackRate = videoWithAudio.playbackRate);
        videoWithAudio.addEventListener("seeked", syncVideos);
        videoWithAudio.addEventListener("timeupdate", syncVideos);

        document.addEventListener("keydown", (event) => {
            if (event.key === "ArrowRight") {
                event.preventDefault(); // Prevent page scrolling
                videoWithAudio.currentTime += seekAmount;
                syncVideos();
            } else if (event.key === "ArrowLeft") {
                event.preventDefault(); // Prevent page scrolling
                videoWithAudio.currentTime -= seekAmount;
                syncVideos();
            } else if (event.key === " " && !event.target.matches("input")) {
                // Spacebar for play/pause, but only if not typing in an input field
                event.preventDefault(); // Prevent page scrolling
                if (videoWithAudio.paused) {
                    videoWithAudio.play();
                } else {
                    videoWithAudio.pause();
                }
            }
        });
        // document.getElementById("openExtension").addEventListener("click", function() {
        //     window.open("chrome-extension://lmppdpldfpfdlipofacekcfleacbbncp/popup/popup.html", "_blank", "width=400,height=600");
        // });
    </script>
</body>
</html>



