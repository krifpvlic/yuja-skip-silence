<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synced Video Player</title>
    <style>
        video { width: 48%; }
        .container { display: flex; justify-content: space-between; }
        .transcript-wrapper {
        display: flex;
        align-items: flex-start; /* Align items at the top */
        position: relative;
        margin-right: 15px; /* Add space for timeline */
        border: 1px solid #ccc;

        margin-top: 20px;
    }
        .transcript-container {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            position: relative;
            
            flex-grow: 1; /* Allow transcript to take up remaining space */

        }
        .transcript-line {
        padding: 4px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
        .transcript-line.active {
            background-color: #e0e0e0;
            border-radius: 5px;
        }
        .bookmark-circle {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
    }
    .bookmark-circle:hover {
        border-color: #666;
    }
    /* Add styles for the bookmark timeline */
    .bookmark-timeline {
        width: 5px;
        height: 220px; /* Match container height */
        background-color: #f0f0f0;
        z-index: 10;
        position: relative;
    }
    .timeline-marker {
        position: absolute;
        left: 0;
        width: 5px;
        height: 5px;
        border-radius: 0;
        cursor: pointer;
    }
    .bookmark-notes {
        position: fixed;
        background: white;
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
    }
    .bookmark-notes textarea {
        width: 200px;
        height: 100px;
        margin-bottom: 10px;
    }
    .color-picker {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
    }
    .color-option {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
    }
    .color-option:hover {
        border-color: #666;
    }
    .bookmark-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
    }
    
    .bookmark-buttons button {
        flex: 1;
        margin: 0 5px;
        padding: 5px;
        cursor: pointer;
    }
    
    .bookmark-buttons button:first-child {
        margin-left: 0;
    }
    
    .bookmark-buttons button:last-child {
        margin-right: 0;
    }
    
        /* Cinema Mode Styles */
        body.cinema-mode {
        background-color: #000;
        color: #fff;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }
    
    .cinema-mode h2,
    .cinema-mode #selectFolderBtn,
    .cinema-mode #selectedFiles,
    .cinema-mode .subtitle-controls {
        display: none;
    }
    
    .cinema-mode .cinema-controls {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 300;
        background-color: rgba(0,0,0,0.5);
        padding: 10px;
        border-radius: 5px;
        display: flex !important;
    }
    
    .cinema-mode .cinema-controls button {
        margin-right: 10px;
        background-color: rgba(255,255,255,0.2);
        color: white;
        border: 1px solid rgba(255,255,255,0.3);
        padding: 5px 10px;
        border-radius: 3px;
        cursor: pointer;
        z-index: 301;
        position: relative;
    }
    
    .cinema-mode .container {
        position: relative;
        width: 100vw;
        height: calc(100vh - 100px);
        display: block;
    }
    
    .cinema-mode #videoWithAudio {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
    
    .cinema-mode #videoWithoutAudio {
        position: absolute;
        top: 50px;
        right: 20px;
        width: 25%;
        height: auto;
        z-index: 100;
        border: 1px solid #444;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        resize: both;
        overflow: auto;
        min-width: 200px;
        min-height: 150px;
    }
    
    .cinema-mode .transcript-wrapper {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100px;
        margin: 0;
        background-color: rgba(0,0,0,0.7);
        border-top: 1px solid #444;
        z-index: 200;
        transition: height 0.3s ease;
    }
    
    .cinema-mode .transcript-container {
        padding: 5px;
        height: 90px !important;
        overflow-y: auto !important;
        /* transition: max-height 0.3s ease; */
    }
    .cinema-mode .transcript-line.active{
        background-color: #343131;
    }
    
    /* .cinema-mode .transcript-wrapper:hover .transcript-container {
        max-height: 200px;
    } */
    
    .cinema-mode .bookmark-timeline {
        height: 100px;
        transition: height 0.3s ease;
    }
    
    /* .cinema-mode .transcript-wrapper:hover .bookmark-timeline {
        height: 200px;
    } */
    
    .cinema-mode .draggable-handle {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 20px;
        background-color: rgba(255,255,255,0.2);
        cursor: move;
        z-index: 101;
        display: block;
    }
    
    .cinema-mode.side-by-side .container {
        display: flex;
        justify-content: space-between;
    }
    
    .cinema-mode.side-by-side #videoWithAudio,
    .cinema-mode.side-by-side #videoWithoutAudio {
        position: relative;
        width: 49%;
        height: 100%;
        top: 0;
        right: 0;
        resize: none;
    }

    .line-text-wrapper {
        display: flex;
        width: 100%;
    }
    </style>
</head>
<body>
    <h2>Synced Video Player</h2>
    
    <!-- Replace individual file inputs with a folder picker -->
    <button id="selectFolderBtn">Select Folder</button>
    <div id="selectedFiles">
        <p>PCI0 Video: <span id="pci0File">None</span></p>
        <p>PCI1 Video: <span id="pci1File">None</span></p>
        <p>Subtitle: <span id="srtFile">None</span></p>
    </div>
    
    <div class="subtitle-controls">
        <label for="subtitleDelay">Subtitle Delay (seconds):</label>
        <input type="number" id="subtitleDelay" step="0.1" value="0">
        
        <label for="subtitleStretch">Subtitle Stretch Factor:</label>
        <input type="number" id="subtitleStretch" step="0.0001" value="1.0000" min="0.5" max="2.0">
        
        <button id="applySubtitleSettings">Apply</button>
        <button id="saveSettings">Save Settings</button>
        <button id="toggleSubtitles">Toggle Subtitles</button>
        <!-- <button id="toggleCinemaMode">Enter Cinema Mode</button> -->
    </div>
    <!-- <div class="cinema-controls" style="display: none;"> -->
        <!-- <button id="exitCinemaMode">Exit Cinema Mode</button>
        <button id="toggleSubtitlesCinema">Toggle Subtitles</button>
        <button id="toggleLayout">Toggle Layout</button> -->
    <!-- </div> -->
    <div class="container">
        <video id="videoWithAudio" controls>
            <track id="subtitleTrack" kind="subtitles" srclang="en" label="English" default>
        </video>
        <video id="videoWithoutAudio" muted></video>
        <!-- <div class="draggable-handle"></div> -->
    </div>
    <div class="transcript-wrapper">
        <div id="transcript" class="transcript-container"></div>
        <div class="bookmark-timeline" id="bookmarkTimeline"></div>
    </div>
    </div>
    
 
    <script>
        const videoWithAudio = document.getElementById("videoWithAudio");
        const videoWithoutAudio = document.getElementById("videoWithoutAudio");
        const subtitleTrack = document.getElementById("subtitleTrack");
        const transcriptContainer = document.getElementById("transcript");
        const bookmarkTimeline = document.getElementById("bookmarkTimeline");
        const toggleSubtitlesBtn = document.getElementById("toggleSubtitles");
        // const toggleSubtitlesCinemaBtn = document.getElementById("toggleSubtitlesCinema");
        // const toggleCinemaModeBtn = document.getElementById("toggleCinemaMode");
        // const exitCinemaModeBtn = document.getElementById("exitCinemaMode");
        // const toggleLayoutBtn = document.getElementById("toggleLayout");
        // const draggableHandle = document.querySelector(".draggable-handle");
        const seekAmount = 5; // Adjust arrow key seek time in seconds
        
        // Cinema mode variables
        let isCinemaMode = false;
        let isSideBySide = false;
        
        // Add cinema mode toggle functionality
        // toggleCinemaModeBtn.addEventListener("click", enterCinemaMode);
        // exitCinemaModeBtn.addEventListener("click", exitCinemaMode);
        // toggleLayoutBtn.addEventListener("click", toggleLayout);
        
                // Make the second video draggable in cinema mode
        //         let isDragging = false;
        // let dragOffsetX = 0;
        // let dragOffsetY = 0;
        
        // draggableHandle.addEventListener("mousedown", (e) => {
        //     if (!isCinemaMode || isSideBySide) return;
        //     isDragging = true;
        //     dragOffsetX = e.clientX - videoWithoutAudio.getBoundingClientRect().left;
        //     dragOffsetY = e.clientY - videoWithoutAudio.getBoundingClientRect().top;
        //     e.preventDefault(); // Prevent text selection during drag
        // });
        
        // document.addEventListener("mousemove", (e) => {
        //     if (!isDragging) return;
            
        //     const containerRect = document.querySelector(".container").getBoundingClientRect();
        //     let newLeft = e.clientX - dragOffsetX;
        //     let newTop = e.clientY - dragOffsetY;
            
        //     // Keep within container bounds
        //     newLeft = Math.max(0, Math.min(newLeft, containerRect.width - videoWithoutAudio.offsetWidth));
        //     newTop = Math.max(0, Math.min(newTop, containerRect.height - videoWithoutAudio.offsetHeight));
            
        //     videoWithoutAudio.style.position = "absolute";
        //     videoWithoutAudio.style.left = newLeft + "px";
        //     videoWithoutAudio.style.top = newTop + "px";
        //     videoWithoutAudio.style.right = "auto";
            
        //     e.preventDefault(); // Prevent text selection during drag
        // });
        
        // document.addEventListener("mouseup", () => {
        //     isDragging = false;
        // });
        
        // Double click on second video to toggle layout
        videoWithoutAudio.addEventListener("dblclick", (e) => {
            if (isCinemaMode) {
                toggleLayout();
            }
        });
        
        // Double click on main video to toggle layout
        videoWithAudio.addEventListener("dblclick", (e) => {
            if (isCinemaMode) {
                toggleLayout();
            }
        });
        
        function enterCinemaMode() {
            isCinemaMode = true;
            document.body.classList.add("cinema-mode");
            document.querySelector(".cinema-controls").style.display = "block";
            document.querySelector(".subtitle-controls").style.display = "none";
            //change the size of transcript to flex
            // document.querySelector(".transcript").style.height = "100%";

            // Make sure the transcript is still scrollable
            // document.querySelector('.transcript-container').style.overflowY = 'auto';
            
            // Limit transcript to show only 3 lines initially
            // limitVisibleTranscriptLines(3);
            
            // Update the bookmark timeline for cinema mode
            updateBookmarkTimeline();
            
            // Make sure the second video is draggable and resizable
            videoWithoutAudio.style.resize = 'both';
            videoWithoutAudio.style.overflow = 'auto';
        }
        
        function exitCinemaMode() {
            isCinemaMode = false;
            isSideBySide = false;
            document.body.classList.remove("cinema-mode", "side-by-side");
            document.querySelector(".cinema-controls").style.display = "none";
            document.querySelector(".subtitle-controls").style.display = "block";
            
            // Reset video styles
            videoWithoutAudio.style.position = "";
            videoWithoutAudio.style.top = "";
            videoWithoutAudio.style.right = "";
            videoWithoutAudio.style.left = "";
            videoWithoutAudio.style.width = "";
            videoWithoutAudio.style.height = "";
            videoWithoutAudio.style.resize = "";
            videoWithoutAudio.style.overflow = "";
            
            // Reset transcript
            document.querySelectorAll('.transcript-line').forEach(line => {
                line.style.display = "flex";
            });
            
            // Update the bookmark timeline for normal mode
            updateBookmarkTimeline();
        }
        function toggleLayout() {
            if (!isCinemaMode) return;
            
            isSideBySide = !isSideBySide;
            
            if (isSideBySide) {
                document.body.classList.add("side-by-side");
                videoWithoutAudio.style.position = "";
                videoWithoutAudio.style.top = "";
                videoWithoutAudio.style.right = "";
                videoWithoutAudio.style.left = "";
            } else {
                document.body.classList.remove("side-by-side");
                videoWithoutAudio.style.position = "absolute";
                videoWithoutAudio.style.top = "10px";
                videoWithoutAudio.style.right = "10px";
                videoWithoutAudio.style.left = "auto";
            }
        }
        
        function limitVisibleTranscriptLines(count) {
            if (!isCinemaMode) return;
            
            const lines = document.querySelectorAll('.transcript-line');
            const activeIndex = currentSubtitleIndex !== -1 ? currentSubtitleIndex : 0;
            
            // Hide all lines first
            lines.forEach(line => {
                line.style.display = "none";
            });
            
            // Show only the specified number of lines around the active one
            const halfCount = Math.floor(count / 2);
            const startIndex = Math.max(0, activeIndex - halfCount);
            const endIndex = Math.min(lines.length - 1, activeIndex + halfCount);
            
            for (let i = startIndex; i <= endIndex; i++) {
                const line = document.querySelector(`.transcript-line[data-index="${i}"]`);
                if (line) {
                    line.style.display = "flex";
                }
            }
        }
        
        // Modify the transcript wrapper hover behavior
        const transcriptWrapper = document.querySelector('.transcript-wrapper');
        // transcriptWrapper.addEventListener('mouseenter', () => {
        //     if (isCinemaMode) {
        //         limitVisibleTranscriptLines(5);
        //     }
        // });
        // transcriptWrapper.addEventListener('mouseenter', () => {
        //     if (isCinemaMode) {
        //         limitVisibleTranscriptLines(5);
        //     }
        // });
        
        // transcriptWrapper.addEventListener('mouseleave', () => {
        //     if (isCinemaMode) {
        //         limitVisibleTranscriptLines(3);
        //     }
        // });
        
        // Modify the updateActiveTranscriptLine function to handle cinema mode
        const originalUpdateActiveTranscriptLine = updateActiveTranscriptLine;
        updateActiveTranscriptLine = function() {
            originalUpdateActiveTranscriptLine();
            
            // If in cinema mode, limit visible lines
            // if (isCinemaMode) {
            //     limitVisibleTranscriptLines(3);
            // }
        };
        
        // Add cinema mode toggle button
        const cinemaModeBtn = document.createElement('button');
        cinemaModeBtn.id = 'toggleCinemaMode';
        cinemaModeBtn.textContent = 'Enter Cinema Mode';
        cinemaModeBtn.addEventListener('click', enterCinemaMode);
        
        // Add the button to the subtitle controls
        document.querySelector('.subtitle-controls').appendChild(cinemaModeBtn);
        
              // Create cinema controls
              const cinemaControls = document.createElement('div');
        cinemaControls.className = 'cinema-controls';
        cinemaControls.style.display = 'none';
        cinemaControls.innerHTML = `
            <button id="exitCinemaMode">Exit Cinema Mode</button>
            <button id="toggleSubtitlesCinema">Toggle Subtitles</button>
            <button id="toggleLayout">Toggle Layout</button>
        `;
        document.body.appendChild(cinemaControls);
        
        // Add event listeners for cinema controls
        document.getElementById('exitCinemaMode').addEventListener('click', (e) => {
            exitCinemaMode();
            e.stopPropagation(); // Prevent event from bubbling up
        });
        
        document.getElementById('toggleSubtitlesCinema').addEventListener('click', (e) => {
            if (subtitleTrack.track.mode === "showing") {
                subtitleTrack.track.mode = "hidden";
                document.getElementById('toggleSubtitlesCinema').textContent = "Show Subtitles";
            } else {
                subtitleTrack.track.mode = "showing";
                document.getElementById('toggleSubtitlesCinema').textContent = "Hide Subtitles";
            }
            e.stopPropagation(); // Prevent event from bubbling up
        });
        
        document.getElementById('toggleLayout').addEventListener('click', (e) => {
            toggleLayout();
            e.stopPropagation(); // Prevent event from bubbling up
        });
        
        // Add draggable handle for the second video
        // const handle = document.createElement('div');
        // handle.className = 'draggable-handle';
        // document.querySelector('.container').appendChild(handle);
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        const draggableHandle = document.querySelector("#videoWithoutAudio");
     draggableHandle.addEventListener("mousedown", (e) => {
        console.log("mousedown");
            if (!isCinemaMode || isSideBySide) return;
            isDragging = true;
            dragOffsetX = e.clientX - videoWithoutAudio.getBoundingClientRect().left;
            dragOffsetY = e.clientY - videoWithoutAudio.getBoundingClientRect().top;
            e.preventDefault(); // Prevent text selection during drag
        });
        
        document.addEventListener("mousemove", (e) => {
            if (!isDragging) return;
            
            const containerRect = document.querySelector(".container").getBoundingClientRect();
            let newLeft = e.clientX - dragOffsetX;
            let newTop = e.clientY - dragOffsetY;
            
            // Keep within container bounds
            newLeft = Math.max(0, Math.min(newLeft, containerRect.width - videoWithoutAudio.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, containerRect.height - videoWithoutAudio.offsetHeight));
            
            videoWithoutAudio.style.position = "absolute";
            videoWithoutAudio.style.left = newLeft + "px";
            videoWithoutAudio.style.top = newTop + "px";
            videoWithoutAudio.style.right = "auto";
            
            e.preventDefault(); // Prevent text selection during drag
        });
        
        document.addEventListener("mouseup", () => {
            isDragging = false;
        });
  
        // Add event listeners to disable default video controls
        videoWithAudio.addEventListener('click', function(e) {
            // Prevent the default click behavior (play/pause)
            e.preventDefault();
            
            // If in cinema mode, handle double click for layout toggle
            // Single clicks won't trigger play/pause anymore
        });
        
        // Prevent spacebar from triggering play/pause
        videoWithAudio.addEventListener('keydown', function(e) {
            if (e.key === " " || e.code === "Space") {
                if(videoWithAudio.paused)
                videoWithAudio.play();
            else videoWithAudio.pause();
            }
        });
        
        
        // Subtitle timing control variables
        const subtitleDelayInput = document.getElementById("subtitleDelay");
        const subtitleStretchInput = document.getElementById("subtitleStretch");
        const applySubtitleSettingsBtn = document.getElementById("applySubtitleSettings");
        const saveSettingsBtn = document.getElementById("saveSettings");
        let subtitleDelay = 0;
        let subtitleStretch = 1.0;
        let originalSrtContent = "";
        let currentSubtitleIndex = -1;
        let subtitles = [];
        
        // File handling variables
        let directoryHandle = null;
        let pci0File = null;
        let pci1File = null;
        let srtFile = null;
        
        // Add variables for tracking video position
        let lastSavedPosition = 0;
        let positionSaveThreshold = 5; // Save when position changes by 5 seconds
        let positionSaveTimer = null;
        
        // Add folder selection functionality
        document.getElementById("selectFolderBtn").addEventListener("click", async () => {
            try {
                directoryHandle = await window.showDirectoryPicker();
                await processDirectory(directoryHandle);
            } catch (error) {
                console.error("Error selecting folder:", error);
                alert("Error selecting folder: " + error.message);
            }
        });
        
        // Process the selected directory to find the required files
        async function processDirectory(dirHandle) {
            pci0File = null;
            pci1File = null;
            srtFile = null;
            
            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file') {
                    const name = entry.name.toLowerCase();
                    
                    if (name.includes('pci0') && (name.endsWith('.mp4') || name.endsWith('.webm') || name.endsWith('.mov'))) {
                        pci0File = entry;
                        document.getElementById("pci0File").textContent = entry.name;
                    } else if (name.includes('pci1') && (name.endsWith('.mp4') || name.endsWith('.webm') || name.endsWith('.mov'))) {
                        pci1File = entry;
                        document.getElementById("pci1File").textContent = entry.name;
                    } else if (name.endsWith('.srt')) {
                        srtFile = entry;
                        document.getElementById("srtFile").textContent = entry.name;
                    } else if (name === 'settings.json') {
                        // Load settings if found
                        await loadSettings(entry);
                    }
                }
            }
            await loadBookmarks();

            
            // Load the files if found
            if (pci0File && pci1File && srtFile) {
                await loadFiles();
            } else {
                alert("Could not find all required files. Please ensure the folder contains files with PCI0, PCI1 in their names and a .srt file.");
            }
        }
        
        // Load the files into the player
        async function loadFiles() {
            try {
                // Load PCI0 video (with audio)
                const pci0FileObj = await pci0File.getFile();
                videoWithAudio.src = URL.createObjectURL(pci0FileObj);
                
                // Load PCI1 video (without audio)
                const pci1FileObj = await pci1File.getFile();
                videoWithoutAudio.src = URL.createObjectURL(pci1FileObj);
                
                // Load subtitle file
                const srtFileObj = await srtFile.getFile();
                const srtContent = await srtFileObj.text();
                originalSrtContent = srtContent;
                updateTranscript(srtContent);
                applySubtitleSettings();
                
                // Set up video position tracking
                videoWithAudio.addEventListener("loadedmetadata", () => {
                    // Set the video position from settings if available
                    if (lastSavedPosition > 0) {
                        videoWithAudio.currentTime = lastSavedPosition;
                    }
                });
                
                // Set up periodic position saving
                let lastSaveTime = Date.now();
                videoWithAudio.addEventListener("timeupdate", () => {
                    const currentTime = videoWithAudio.currentTime;
                    const now = Date.now();
                    if(now-lastSaveTime >= 5500){
                        lastSaveTime = now;
                    }
                    
                    // Save if position changed significantly or enough time has passed (10 seconds)
                    if (Math.abs(currentTime - lastSavedPosition) >= positionSaveThreshold && 
                        now - lastSaveTime >= 5000) {
                        lastSavedPosition = currentTime;
                        lastSaveTime = now;
                        saveSettings();
                    }
                });
                // Check if enough time has passed since last save
                // const currentTime = videoWithAudio.currentTime;
                // if (Math.abs(currentTime - lastSavedPosition) >= positionSaveThreshold) {
                //     lastSavedPosition = currentTime;
                //     saveSettings();
                // }
                //
                // Still keep the debounce timer for when video is paused
                // clearTimeout(positionSaveTimer);
                // positionSaveTimer = setTimeout(saveVideoPosition, 1000);
            } catch (error) {
                console.error("Error loading files:", error);
                alert("Error loading files: " + error.message);
            }
        }
        
        // Save settings to settings.json
        async function saveSettings() {
            if (!directoryHandle) {
                alert("Please select a folder first");
                return;
            }
            
            const settings = {
                subtitleDelay: parseFloat(subtitleDelayInput.value) || 0,
                subtitleStretch: parseFloat(subtitleStretchInput.value) || 1.0,
                videoPosition: videoWithAudio.currentTime || 0
            };
            
            try {
                // Create or overwrite settings.json
                const settingsFileHandle = await directoryHandle.getFileHandle('settings.json', { create: true });
                const writable = await settingsFileHandle.createWritable();
                await writable.write(JSON.stringify(settings, null, 2));
                await writable.close();
                console.log("Settings saved successfully");
            } catch (error) {
                console.error("Error saving settings:", error);
            }
        }
        
        // Load settings from settings.json
        async function loadSettings(fileHandle) {
            try {
                const file = await fileHandle.getFile();
                const content = await file.text();
                const settings = JSON.parse(content);
                
                if (settings.subtitleDelay !== undefined) {
                    subtitleDelayInput.value = settings.subtitleDelay;
                    subtitleDelay = settings.subtitleDelay;
                }
                
                if (settings.subtitleStretch !== undefined) {
                    subtitleStretchInput.value = settings.subtitleStretch;
                    subtitleStretch = settings.subtitleStretch;
                }
                
                if (settings.videoPosition !== undefined) {
                    lastSavedPosition = settings.videoPosition;
                }
                
                console.log("Settings loaded:", settings);
            } catch (error) {
                console.error("Error loading settings:", error);
            }
        }
        
        // Add function to save video position
        function saveVideoPosition() {
            if (!directoryHandle) return;
            
            const currentPosition = videoWithAudio.currentTime;
            // Only save if position changed by more than threshold
            if (Math.abs(currentPosition - lastSavedPosition) >= positionSaveThreshold) {
                lastSavedPosition = currentPosition;
                saveSettings();
            }
        }
        
        // Add event listener for save settings button
        saveSettingsBtn.addEventListener("click", saveSettings);

        toggleSubtitlesBtn.addEventListener("click", () => {
            if (subtitleTrack.track.mode === "showing") {
                subtitleTrack.track.mode = "hidden";
                toggleSubtitlesBtn.textContent = "Show Subtitles";
            } else {
                subtitleTrack.track.mode = "showing";
                toggleSubtitlesBtn.textContent = "Hide Subtitles";
            }
        });

        // Add bookmark-related variables
        let bookmarks = {};
        const defaultBookmarkColor = '#87CEEB'; // light blue
        const bookmarkColors = ['#87CEEB', '#90EE90', '#FFB6C1', '#DDA0DD', '#F0E68C']; // light blue, light green, light pink, plum, khaki
        
        // Load bookmarks from bookmarks.json
        async function loadBookmarks() {
            if (!directoryHandle) return;
            
            try {
                const bookmarksHandle = await directoryHandle.getFileHandle('bookmarks.json', { create: true });
                const file = await bookmarksHandle.getFile();
                const content = await file.text();
                bookmarks = JSON.parse(content || '{}');
                updateBookmarkTimeline();
            } catch (error) {
                console.error("Error loading bookmarks:", error);
                bookmarks = {};
            }
        }
        
        // Save bookmarks to bookmarks.json
        async function saveBookmarks() {
            if (!directoryHandle) return;
            
            try {
                const bookmarksHandle = await directoryHandle.getFileHandle('bookmarks.json', { create: true });
                const writable = await bookmarksHandle.createWritable();
                await writable.write(JSON.stringify(bookmarks, null, 2));
                await writable.close();
            } catch (error) {
                console.error("Error saving bookmarks:", error);
            }
        }
        
        // Modify the updateTranscript function
        function updateTranscript(srtContent) {
            subtitles = parseSRT(srtContent);
            transcriptContainer.innerHTML = `
                ${subtitles
                    .map((sub, index) => `
                        <div class="transcript-line" data-index="${index}">
                            <div class="line-text-wrapper">
                            <span>${sub.text}</span>
                            </div>
                            <div class="bookmark-circle" data-index="${index}" 
                                 style="background-color: ${bookmarks[index]?.color || 'transparent'}">
                            </div>
                        </div>
                    `).join("")}
            `;
            
            // Add click handlers for transcript lines and bookmarks
            document.querySelectorAll('.transcript-line').forEach(line => {
                const index = parseInt(line.dataset.index);
                
                // Text click handler
                line.querySelector('.line-text-wrapper').addEventListener('click', () => {
                    const adjustedTime = subtitles[index].startTime * subtitleStretch + subtitleDelay;
                    videoWithAudio.currentTime = adjustedTime;
                });
                
                // Bookmark click handler
                const bookmarkCircle = line.querySelector('.bookmark-circle');
                bookmarkCircle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleBookmarkClick(index, bookmarkCircle);
                });
            });
            
            // Update the bookmark timeline
            updateBookmarkTimeline();
            
            // Add keyboard navigation for transcript
            transcriptContainer.tabIndex = 0; // Make the container focusable
            transcriptContainer.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    event.preventDefault(); // Prevent default scrolling
                    
                    // Find the current active line or use the first one
                    const activeLine = document.querySelector('.transcript-line.active') || 
                                       document.querySelector('.transcript-line');
                    if (!activeLine) return;
                    
                    const currentIndex = parseInt(activeLine.dataset.index);
                    let newIndex;
                    
                    if (event.key === 'ArrowDown' && currentIndex < subtitles.length - 1) {
                        newIndex = currentIndex + 1;
                    } else if (event.key === 'ArrowUp' && currentIndex > 0) {
                        newIndex = currentIndex - 1;
                    } else {
                        return; // No valid navigation
                    }
                    
                    // Simulate clicking the new line
                    const newLine = document.querySelector(`.transcript-line[data-index="${newIndex}"]`);
                    if (newLine) {
                        newLine.click();
                        newLine.focus(); // Optional: focus the new line for accessibility
                    }
                }
            });
        }
        // Add a new function to update the bookmark timeline
function updateBookmarkTimeline() {
    const timeline = document.getElementById('bookmarkTimeline');
    timeline.innerHTML = '';
    
    if (subtitles.length === 0) return;
    
    // Create markers for each bookmark
    Object.keys(bookmarks).forEach(index => {
        const i = parseInt(index);
        if (i >= 0 && i < subtitles.length) {
            const position = (i / subtitles.length) * 100;
            const marker = document.createElement('div');
            console.log("creating marker at position", position);
            marker.className = 'timeline-marker';
            const markerHeight = 5; // Set a consistent height for markers
            marker.style.height = `${markerHeight}px`;
            const adjustedPosition = (position * (100 - markerHeight/timeline.clientHeight*100)) / 100;
            marker.style.top = `${adjustedPosition}%`;
            marker.style.backgroundColor = bookmarks[i].color;
            marker.dataset.index = i;

            
            // Add click handler to jump to the bookmark
            marker.addEventListener('click', () => {
                const adjustedTime = subtitles[i].startTime * subtitleStretch + subtitleDelay;
                videoWithAudio.currentTime = adjustedTime;
                
                // Scroll to the corresponding transcript line
                const line = document.querySelector(`.transcript-line[data-index="${i}"]`);
                if (line) {
                    scrollParentToChild(transcriptContainer, line);
                }
            });
            timeline.appendChild(marker);
        }
    });
}


function handleBookmarkClick(index, circle) {
    if (bookmarks[index]) {
        showBookmarkNotes(index, circle);
    } else {
        // Create new bookmark
        bookmarks[index] = {
            color: defaultBookmarkColor,
            notes: ''
        };
        circle.style.backgroundColor = defaultBookmarkColor;
        showBookmarkNotes(index, circle);
        saveBookmarks();
        updateBookmarkTimeline();
    }
}

function showBookmarkNotes(index, circle) {
    const existingNotes = document.querySelector('.bookmark-notes');
    if (existingNotes) existingNotes.remove();
    
    const notesDiv = document.createElement('div');
    notesDiv.className = 'bookmark-notes';
    notesDiv.innerHTML = `
        <div class="color-picker">
            ${bookmarkColors.map(color => 
                `<div class="color-option" style="background-color: ${color}"></div>`
            ).join('')}
        </div>
        <textarea placeholder="Add notes...">${bookmarks[index]?.notes || ''}</textarea>
        <div class="bookmark-buttons">
            <button class="save-btn">Save</button>
            <button class="cancel-btn">Cancel</button>
            <button class="delete-btn">Delete</button>
        </div>
    `;
    
    // Position the notes div
    const rect = circle.getBoundingClientRect();
    document.body.appendChild(notesDiv);
    
    // Calculate position to keep dialog within viewport
    const dialogWidth = notesDiv.offsetWidth;
    const dialogHeight = notesDiv.offsetHeight;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Default position near the circle
    let top = rect.top;
    let left = rect.right + 10;
    
    // Adjust if it would go off the right edge
    if (left + dialogWidth > viewportWidth) {
        left = rect.left - dialogWidth - 10;
    }
    
    // Adjust if it would go off the bottom edge
    if (top + dialogHeight > viewportHeight) {
        top = viewportHeight - dialogHeight - 10;
    }
    
    // Adjust if it would go off the top edge
    if (top < 10) {
        top = 10;
    }
    
    notesDiv.style.top = `${top}px`;
    notesDiv.style.left = `${left}px`;
    
    // Color picker handlers
    notesDiv.querySelectorAll('.color-option').forEach(colorDiv => {
        colorDiv.addEventListener('click', () => {
            const color = colorDiv.style.backgroundColor;
            bookmarks[index].color = color;
            circle.style.backgroundColor = color;
            saveBookmarks();
        });
    });
    
    // Button handlers
    const saveBtn = notesDiv.querySelector('.save-btn');
    const cancelBtn = notesDiv.querySelector('.cancel-btn');
    const deleteBtn = notesDiv.querySelector('.delete-btn');
    
    saveBtn.addEventListener('click', () => {
        bookmarks[index].notes = notesDiv.querySelector('textarea').value;
        saveBookmarks();
        updateBookmarkTimeline();
        notesDiv.remove();
        document.removeEventListener('click', closeNotes); // Remove the event listener
    });
    
    cancelBtn.addEventListener('click', () => {
        notesDiv.remove();
        document.removeEventListener('click', closeNotes); // Remove the event listener
    });
    
    deleteBtn.addEventListener('click', () => {
        delete bookmarks[index];
        circle.style.backgroundColor = 'transparent';
        saveBookmarks();
        updateBookmarkTimeline();
        notesDiv.remove();
        document.removeEventListener('click', closeNotes); // Remove the event listener
    });
    
    // Click outside to close and save
    document.addEventListener('click', function closeNotes(e) {
        if (!notesDiv.contains(e.target) && e.target !== circle) {
            // Save notes before closing
            bookmarks[index].notes = notesDiv.querySelector('textarea').value;
            saveBookmarks();
            updateBookmarkTimeline();
            
            notesDiv.remove();
            document.removeEventListener('click', closeNotes);
        }
    });
}

        function parseSRT(srtContent) {
            const parsed = [];
            const blocks = srtContent.trim().split('\n\n');
            
            blocks.forEach(block => {
                const lines = block.split('\n');
                if (lines.length >= 3) {
                    const times = lines[1].match(/(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/);
                    if (times) {
                        const startTime = parseInt(times[1]) * 3600 + parseInt(times[2]) * 60 + parseInt(times[3]) + parseInt(times[4]) / 1000;
                        const text = lines.slice(2).join('\n');
                        parsed.push({ startTime, text });
                    }
                }
            });
            return parsed;
        }

        function scrollParentToChild(parent, child) {
            // Get the parent's dimensions and position
            const parentRect = parent.getBoundingClientRect();
            const parentHeight = parent.clientHeight;
            
            // Get the child's dimensions and position
            const childRect = child.getBoundingClientRect();
            const childHeight = child.offsetHeight;
            
            // Calculate the position that would center the child in the parent
            const childRelativeTop = childRect.top - parentRect.top;
            const targetScrollTop = parent.scrollTop + childRelativeTop - (parentHeight/2) + (childHeight/2);
            
            // Smoothly scroll to center the child
            parent.scrollTo({
                top: targetScrollTop,
                behavior: 'smooth'
            });
        }

        function updateActiveTranscriptLine() {
            const currentTime = videoWithAudio.currentTime;
            const newIndex = subtitles.findIndex((sub, index) => {
                const nextSub = subtitles[index + 1];
                // Adjust the subtitle timing with stretch and delay
                const adjustedStartTime = sub.startTime * subtitleStretch + subtitleDelay;
                const adjustedNextTime = nextSub ? nextSub.startTime * subtitleStretch + subtitleDelay : Infinity;
                
                return currentTime >= adjustedStartTime && currentTime < adjustedNextTime;
            });

            if (newIndex !== currentSubtitleIndex && newIndex !== -1) {
                document.querySelectorAll('.transcript-line').forEach(el => el.classList.remove('active'));
                const activeLine = document.querySelector(`.transcript-line[data-index="${newIndex}"]`);
                if (activeLine) {
                    activeLine.classList.add('active');
                    scrollParentToChild(transcriptContainer, activeLine);
                }
                currentSubtitleIndex = newIndex;
            }
        }
        
        // Modify the existing subtitle input handler
        // document.getElementById("subtitleInput").addEventListener("change", function(event) {
        //     const file = event.target.files[0];
        //     const reader = new FileReader();
        //     reader.onload = function(e) {
        //         originalSrtContent = e.target.result;
        //         updateTranscript(originalSrtContent);
        //         applySubtitleSettings();
        //     };
        //     reader.readAsText(file);
        // });

        // Add timeupdate listener for transcript tracking
        videoWithAudio.addEventListener("timeupdate", updateActiveTranscriptLine);

        applySubtitleSettingsBtn.addEventListener("click", applySubtitleSettings);

        function applySubtitleSettings() {
            if (!originalSrtContent) return;
            
            subtitleDelay = parseFloat(subtitleDelayInput.value) || 0;
            subtitleStretch = parseFloat(subtitleStretchInput.value) || 1.0;
            
            const vttData = convertSRTtoVTT(originalSrtContent, subtitleDelay, subtitleStretch);
            const blob = new Blob([vttData], { type: "text/vtt" });
            subtitleTrack.src = URL.createObjectURL(blob);
            subtitleTrack.track.mode = "showing";
        }

        function convertSRTtoVTT(data, delay = 0, stretch = 1.0) {
            // console.log("Original SRT data:", data);
            let vtt = "WEBVTT\n\n" + data
                .replace(/(\d+)\n(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/g, 
                         (match, id, h1, m1, s1, ms1, h2, m2, s2, ms2) => {
                            //  console.log("Match found:", match);
                             
                             // Convert timestamps to seconds
                             let startTime = parseInt(h1) * 3600 + parseInt(m1) * 60 + parseInt(s1) + parseInt(ms1) / 1000;
                             let endTime = parseInt(h2) * 3600 + parseInt(m2) * 60 + parseInt(s2) + parseInt(ms2) / 1000;
                             
                             // Apply stretch and delay
                             startTime = startTime * stretch + delay;
                             endTime = endTime * stretch + delay;
                             
                             // Convert back to timestamp format
                             let newH1 = Math.floor(
                                 startTime / 3600).toString().padStart(2, '0');
                             let newM1 = Math.floor((startTime % 3600) / 60).toString().padStart(2, '0');
                             let newS1 = Math.floor(startTime % 60).toString().padStart(2, '0');
                             let newMs1 = Math.floor((startTime % 1) * 1000).toString().padStart(3, '0');
                             
                             let newH2 = Math.floor(endTime / 3600).toString().padStart(2, '0');
                             let newM2 = Math.floor((endTime % 3600) / 60).toString().padStart(2, '0');
                             let newS2 = Math.floor(endTime % 60).toString().padStart(2, '0');
                             let newMs2 = Math.floor((endTime % 1) * 1000).toString().padStart(3, '0');
                             
                            //  console.log("Adjusted timestamp:", `${newH1}:${newM1}:${newS1}.${newMs1} --> ${newH2}:${newM2}:${newS2}.${newMs2}`);
                             return `${id}\n${newH1}:${newM1}:${newS1}.${newMs1} --> ${newH2}:${newM2}:${newS2}.${newMs2}`;
                         });
            // console.log("Converted VTT data:", vtt);
            return vtt;
        }


       
        // Add save settings button event listener
        document.getElementById("saveSettings").addEventListener("click", saveSettings);


        function syncVideos() {
            videoWithoutAudio.currentTime = videoWithAudio.currentTime;
            // Removed the line that forces subtitles to show
        }

        videoWithAudio.addEventListener("play", () => {
            videoWithoutAudio.play();
            syncVideos();
        });
        videoWithAudio.addEventListener("pause", () => videoWithoutAudio.pause());
        videoWithAudio.addEventListener("ratechange", () => videoWithoutAudio.playbackRate = videoWithAudio.playbackRate);
        videoWithAudio.addEventListener("seeked", syncVideos);
        videoWithAudio.addEventListener("timeupdate", syncVideos);
        

        document.addEventListener("keydown", (event) => {
            if (event.key === "ArrowRight") {
                event.preventDefault(); // Prevent page scrolling
                videoWithAudio.currentTime += seekAmount;
                syncVideos();
            } else if (event.key === "ArrowLeft") {
                event.preventDefault(); // Prevent page scrolling
                videoWithAudio.currentTime -= seekAmount;
                syncVideos();
            } else if (event.key === " " && !event.target.matches("input")) {
                // Spacebar for play/pause, but only if not typing in an input field
                event.preventDefault(); // Prevent page scrolling
                if (videoWithAudio.paused) {
                    videoWithAudio.play();
                } else {
                    videoWithAudio.pause();
                }
            }
        });
        // document.getElementById("openExtension").addEventListener("click", function() {
        //     window.open("chrome-extension://lmppdpldfpfdlipofacekcfleacbbncp/popup/popup.html", "_blank", "width=400,height=600");
        // });
    </script>
</body>
</html>