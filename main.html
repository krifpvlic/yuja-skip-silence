<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synced Video Player</title>
    <style>
        video { width: 48%; }
        .container { display: flex; justify-content: space-between; }
        .transcript-container {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 20px;
        }
        .transcript-line {
            padding: 4px;
            cursor: pointer;
        }
        .transcript-line.active {
            background-color: #e0e0e0;
        }
    </style>
</head>
<body>
    <h2>Synced Video Player</h2>
    
    <!-- Replace individual file inputs with a folder picker -->
    <button id="selectFolderBtn">Select Folder</button>
    <div id="selectedFiles">
        <p>PCI0 Video: <span id="pci0File">None</span></p>
        <p>PCI1 Video: <span id="pci1File">None</span></p>
        <p>Subtitle: <span id="srtFile">None</span></p>
    </div>
    
    <div class="subtitle-controls">
        <label for="subtitleDelay">Subtitle Delay (seconds):</label>
        <input type="number" id="subtitleDelay" step="0.1" value="0">
        
        <label for="subtitleStretch">Subtitle Stretch Factor:</label>
        <input type="number" id="subtitleStretch" step="0.0001" value="1.0000" min="0.5" max="2.0">
        
        <button id="applySubtitleSettings">Apply</button>
        <button id="saveSettings">Save Settings</button>
        <button id="toggleSubtitles">Toggle Subtitles</button>
    </div>
    
    <div class="container">
        <video id="videoWithAudio" controls>
            <track id="subtitleTrack" kind="subtitles" srclang="en" label="English" default>
        </video>
        <video id="videoWithoutAudio" muted></video>
    </div>
    
    <div id="transcript" class="transcript-container"></div>
    
    <script>
        const videoWithAudio = document.getElementById("videoWithAudio");
        const videoWithoutAudio = document.getElementById("videoWithoutAudio");
        const subtitleTrack = document.getElementById("subtitleTrack");
        const transcriptContainer = document.getElementById("transcript");
        const toggleSubtitlesBtn = document.getElementById("toggleSubtitles");
        const seekAmount = 5; // Adjust arrow key seek time in seconds
        
        // Subtitle timing control variables
        const subtitleDelayInput = document.getElementById("subtitleDelay");
        const subtitleStretchInput = document.getElementById("subtitleStretch");
        const applySubtitleSettingsBtn = document.getElementById("applySubtitleSettings");
        const saveSettingsBtn = document.getElementById("saveSettings");
        let subtitleDelay = 0;
        let subtitleStretch = 1.0;
        let originalSrtContent = "";
        let currentSubtitleIndex = -1;
        let subtitles = [];
        
        // File handling variables
        let directoryHandle = null;
        let pci0File = null;
        let pci1File = null;
        let srtFile = null;
        
        // Add folder selection functionality
        document.getElementById("selectFolderBtn").addEventListener("click", async () => {
            try {
                directoryHandle = await window.showDirectoryPicker();
                await processDirectory(directoryHandle);
            } catch (error) {
                console.error("Error selecting folder:", error);
                alert("Error selecting folder: " + error.message);
            }
        });
        
        // Process the selected directory to find the required files
        async function processDirectory(dirHandle) {
            pci0File = null;
            pci1File = null;
            srtFile = null;
            
            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file') {
                    const name = entry.name.toLowerCase();
                    
                    if (name.includes('pci0') && (name.endsWith('.mp4') || name.endsWith('.webm') || name.endsWith('.mov'))) {
                        pci0File = entry;
                        document.getElementById("pci0File").textContent = entry.name;
                    } else if (name.includes('pci1') && (name.endsWith('.mp4') || name.endsWith('.webm') || name.endsWith('.mov'))) {
                        pci1File = entry;
                        document.getElementById("pci1File").textContent = entry.name;
                    } else if (name.endsWith('.srt')) {
                        srtFile = entry;
                        document.getElementById("srtFile").textContent = entry.name;
                    } else if (name === 'settings.json') {
                        // Load settings if found
                        await loadSettings(entry);
                    }
                }
            }
            
            // Load the files if found
            if (pci0File && pci1File && srtFile) {
                await loadFiles();
            } else {
                alert("Could not find all required files. Please ensure the folder contains files with PCI0, PCI1 in their names and a .srt file.");
            }
        }
        
        // Load the files into the player
        async function loadFiles() {
            try {
                // Load PCI0 video (with audio)
                const pci0FileObj = await pci0File.getFile();
                videoWithAudio.src = URL.createObjectURL(pci0FileObj);
                
                // Load PCI1 video (without audio)
                const pci1FileObj = await pci1File.getFile();
                videoWithoutAudio.src = URL.createObjectURL(pci1FileObj);
                
                // Load subtitle file
                const srtFileObj = await srtFile.getFile();
                const srtContent = await srtFileObj.text();
                originalSrtContent = srtContent;
                updateTranscript(srtContent);
                applySubtitleSettings();
            } catch (error) {
                console.error("Error loading files:", error);
                alert("Error loading files: " + error.message);
            }
        }
        
        // Save settings to settings.json
        async function saveSettings() {
            if (!directoryHandle) {
                alert("Please select a folder first");
                return;
            }
            
            const settings = {
                subtitleDelay: parseFloat(subtitleDelayInput.value) || 0,
                subtitleStretch: parseFloat(subtitleStretchInput.value) || 1.0
            };
            
            try {
                // Create or overwrite settings.json
                const settingsFileHandle = await directoryHandle.getFileHandle('settings.json', { create: true });
                const writable = await settingsFileHandle.createWritable();
                await writable.write(JSON.stringify(settings, null, 2));
                await writable.close();
                alert("Settings saved successfully");
            } catch (error) {
                console.error("Error saving settings:", error);
                alert("Error saving settings: " + error.message);
            }
        }
        
        // Load settings from settings.json
        async function loadSettings(fileHandle) {
            try {
                const file = await fileHandle.getFile();
                const content = await file.text();
                const settings = JSON.parse(content);
                
                if (settings.subtitleDelay !== undefined) {
                    subtitleDelayInput.value = settings.subtitleDelay;
                    subtitleDelay = settings.subtitleDelay;
                }
                
                if (settings.subtitleStretch !== undefined) {
                    subtitleStretchInput.value = settings.subtitleStretch;
                    subtitleStretch = settings.subtitleStretch;
                }
                
                console.log("Settings loaded:", settings);
            } catch (error) {
                console.error("Error loading settings:", error);
            }
        }
        
        // Add event listener for save settings button
        saveSettingsBtn.addEventListener("click", saveSettings);

        toggleSubtitlesBtn.addEventListener("click", () => {
            if (subtitleTrack.track.mode === "showing") {
                subtitleTrack.track.mode = "hidden";
                toggleSubtitlesBtn.textContent = "Show Subtitles";
            } else {
                subtitleTrack.track.mode = "showing";
                toggleSubtitlesBtn.textContent = "Hide Subtitles";
            }
        });

        function updateTranscript(srtContent) {
            subtitles = parseSRT(srtContent);
            transcriptContainer.innerHTML = subtitles
                .map((sub, index) => `<div class="transcript-line" data-index="${index}">${sub.text}</div>`)
                .join("");
            
            // Add click handlers to transcript lines
            document.querySelectorAll('.transcript-line').forEach(line => {
                line.addEventListener('click', () => {
                    const index = parseInt(line.dataset.index);
                    // Apply the same delay and stretch factor as subtitles
                    const adjustedTime = subtitles[index].startTime * subtitleStretch + subtitleDelay;
                    videoWithAudio.currentTime = adjustedTime;
                });
            });
            
            // Add keyboard navigation for transcript
            transcriptContainer.tabIndex = 0; // Make the container focusable
            transcriptContainer.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    event.preventDefault(); // Prevent default scrolling
                    
                    // Find the current active line or use the first one
                    const activeLine = document.querySelector('.transcript-line.active') || 
                                       document.querySelector('.transcript-line');
                    if (!activeLine) return;
                    
                    const currentIndex = parseInt(activeLine.dataset.index);
                    let newIndex;
                    
                    if (event.key === 'ArrowDown' && currentIndex < subtitles.length - 1) {
                        newIndex = currentIndex + 1;
                    } else if (event.key === 'ArrowUp' && currentIndex > 0) {
                        newIndex = currentIndex - 1;
                    } else {
                        return; // No valid navigation
                    }
                    
                    // Simulate clicking the new line
                    const newLine = document.querySelector(`.transcript-line[data-index="${newIndex}"]`);
                    if (newLine) {
                        newLine.click();
                        newLine.focus(); // Optional: focus the new line for accessibility
                    }
                }
            });
        }

        function parseSRT(srtContent) {
            const parsed = [];
            const blocks = srtContent.trim().split('\n\n');
            
            blocks.forEach(block => {
                const lines = block.split('\n');
                if (lines.length >= 3) {
                    const times = lines[1].match(/(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/);
                    if (times) {
                        const startTime = parseInt(times[1]) * 3600 + parseInt(times[2]) * 60 + parseInt(times[3]) + parseInt(times[4]) / 1000;
                        const text = lines.slice(2).join('\n');
                        parsed.push({ startTime, text });
                    }
                }
            });
            return parsed;
        }

        function scrollParentToChild(parent, child) {
            // Get the parent's dimensions and position
            const parentRect = parent.getBoundingClientRect();
            const parentHeight = parent.clientHeight;
            
            // Get the child's dimensions and position
            const childRect = child.getBoundingClientRect();
            const childHeight = child.offsetHeight;
            
            // Calculate the position that would center the child in the parent
            const childRelativeTop = childRect.top - parentRect.top;
            const targetScrollTop = parent.scrollTop + childRelativeTop - (parentHeight/2) + (childHeight/2);
            
            // Smoothly scroll to center the child
            parent.scrollTo({
                top: targetScrollTop,
                behavior: 'smooth'
            });
        }

        function updateActiveTranscriptLine() {
            const currentTime = videoWithAudio.currentTime;
            const newIndex = subtitles.findIndex((sub, index) => {
                const nextSub = subtitles[index + 1];
                // Adjust the subtitle timing with stretch and delay
                const adjustedStartTime = sub.startTime * subtitleStretch + subtitleDelay;
                const adjustedNextTime = nextSub ? nextSub.startTime * subtitleStretch + subtitleDelay : Infinity;
                
                return currentTime >= adjustedStartTime && currentTime < adjustedNextTime;
            });

            if (newIndex !== currentSubtitleIndex && newIndex !== -1) {
                document.querySelectorAll('.transcript-line').forEach(el => el.classList.remove('active'));
                const activeLine = document.querySelector(`.transcript-line[data-index="${newIndex}"]`);
                if (activeLine) {
                    activeLine.classList.add('active');
                    scrollParentToChild(transcriptContainer, activeLine);
                }
                currentSubtitleIndex = newIndex;
            }
        }
        
        // Modify the existing subtitle input handler
        // document.getElementById("subtitleInput").addEventListener("change", function(event) {
        //     const file = event.target.files[0];
        //     const reader = new FileReader();
        //     reader.onload = function(e) {
        //         originalSrtContent = e.target.result;
        //         updateTranscript(originalSrtContent);
        //         applySubtitleSettings();
        //     };
        //     reader.readAsText(file);
        // });

        // Add timeupdate listener for transcript tracking
        videoWithAudio.addEventListener("timeupdate", updateActiveTranscriptLine);

        applySubtitleSettingsBtn.addEventListener("click", applySubtitleSettings);

        function applySubtitleSettings() {
            if (!originalSrtContent) return;
            
            subtitleDelay = parseFloat(subtitleDelayInput.value) || 0;
            subtitleStretch = parseFloat(subtitleStretchInput.value) || 1.0;
            
            const vttData = convertSRTtoVTT(originalSrtContent, subtitleDelay, subtitleStretch);
            const blob = new Blob([vttData], { type: "text/vtt" });
            subtitleTrack.src = URL.createObjectURL(blob);
            subtitleTrack.track.mode = "showing";
        }

        function convertSRTtoVTT(data, delay = 0, stretch = 1.0) {
            console.log("Original SRT data:", data);
            let vtt = "WEBVTT\n\n" + data
                .replace(/(\d+)\n(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/g, 
                         (match, id, h1, m1, s1, ms1, h2, m2, s2, ms2) => {
                             console.log("Match found:", match);
                             
                             // Convert timestamps to seconds
                             let startTime = parseInt(h1) * 3600 + parseInt(m1) * 60 + parseInt(s1) + parseInt(ms1) / 1000;
                             let endTime = parseInt(h2) * 3600 + parseInt(m2) * 60 + parseInt(s2) + parseInt(ms2) / 1000;
                             
                             // Apply stretch and delay
                             startTime = startTime * stretch + delay;
                             endTime = endTime * stretch + delay;
                             
                             // Convert back to timestamp format
                             let newH1 = Math.floor(
                                 startTime / 3600).toString().padStart(2, '0');
                             let newM1 = Math.floor((startTime % 3600) / 60).toString().padStart(2, '0');
                             let newS1 = Math.floor(startTime % 60).toString().padStart(2, '0');
                             let newMs1 = Math.floor((startTime % 1) * 1000).toString().padStart(3, '0');
                             
                             let newH2 = Math.floor(endTime / 3600).toString().padStart(2, '0');
                             let newM2 = Math.floor((endTime % 3600) / 60).toString().padStart(2, '0');
                             let newS2 = Math.floor(endTime % 60).toString().padStart(2, '0');
                             let newMs2 = Math.floor((endTime % 1) * 1000).toString().padStart(3, '0');
                             
                             console.log("Adjusted timestamp:", `${newH1}:${newM1}:${newS1}.${newMs1} --> ${newH2}:${newM2}:${newS2}.${newMs2}`);
                             return `${id}\n${newH1}:${newM1}:${newS1}.${newMs1} --> ${newH2}:${newM2}:${newS2}.${newMs2}`;
                         });
            console.log("Converted VTT data:", vtt);
            return vtt;
        }
        async function saveSettings() {
            if (!directoryHandle) {
                alert("Please select a folder first");
                return;
            }
            
            const settings = {
                subtitleDelay: parseFloat(subtitleDelayInput.value) || 0,
                subtitleStretch: parseFloat(subtitleStretchInput.value) || 1.0
            };
            
            try {
                const settingsHandle = await directoryHandle.getFileHandle('settings.json', { create: true });
                const writable = await settingsHandle.createWritable();
                await writable.write(JSON.stringify(settings, null, 2));
                await writable.close();
                alert("Settings saved successfully");
            } catch (error) {
                console.error("Error saving settings:", error);
                alert("Error saving settings: " + error.message);
            }
        }

        // Load settings from settings.json
        async function loadSettings() {
            if (!directoryHandle) return;
            
            try {
                const settingsHandle = await directoryHandle.getFileHandle('settings.json');
                const file = await settingsHandle.getFile();
                const content = await file.text();
                const settings = JSON.parse(content);
                
                if (settings.subtitleDelay !== undefined) {
                    subtitleDelayInput.value = settings.subtitleDelay;
                    subtitleDelay = settings.subtitleDelay;
                }
                
                if (settings.subtitleStretch !== undefined) {
                    subtitleStretchInput.value = settings.subtitleStretch;
                    subtitleStretch = settings.subtitleStretch;
                }
                
                applySubtitleSettings();
            } catch (error) {
                console.error("Error loading settings:", error);
            }
        }

        // Add save settings button event listener
        document.getElementById("saveSettings").addEventListener("click", saveSettings);


        function syncVideos() {
            videoWithoutAudio.currentTime = videoWithAudio.currentTime;
            // Removed the line that forces subtitles to show
        }

        videoWithAudio.addEventListener("play", () => {
            videoWithoutAudio.play();
            syncVideos();
        });
        videoWithAudio.addEventListener("pause", () => videoWithoutAudio.pause());
        videoWithAudio.addEventListener("ratechange", () => videoWithoutAudio.playbackRate = videoWithAudio.playbackRate);
        videoWithAudio.addEventListener("seeked", syncVideos);
        videoWithAudio.addEventListener("timeupdate", syncVideos);

        document.addEventListener("keydown", (event) => {
            if (event.key === "ArrowRight") {
                event.preventDefault(); // Prevent page scrolling
                videoWithAudio.currentTime += seekAmount;
                syncVideos();
            } else if (event.key === "ArrowLeft") {
                event.preventDefault(); // Prevent page scrolling
                videoWithAudio.currentTime -= seekAmount;
                syncVideos();
            } else if (event.key === " " && !event.target.matches("input")) {
                // Spacebar for play/pause, but only if not typing in an input field
                event.preventDefault(); // Prevent page scrolling
                if (videoWithAudio.paused) {
                    videoWithAudio.play();
                } else {
                    videoWithAudio.pause();
                }
            }
        });
        document.getElementById("openExtension").addEventListener("click", function() {
            window.open("chrome-extension://lmppdpldfpfdlipofacekcfleacbbncp/popup/popup.html", "_blank", "width=400,height=600");
        });
    </script>
</body>
</html>
